<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>RAWobserved - Graph (clustered forces)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: dark;
        }

        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            background: #0b0f14;
            color: #e6ebf2;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        }

        #app {
            display: grid;
            grid-template-columns: 400px 1fr;
            height: 100vh;
        }

        #side {
            padding: 14px;
            border-right: 1px solid #182130;
            background: #0e131a;
            overflow: auto;
        }

        #stage {
            position: relative;
            min-width: 0;
            min-height: 0;
        }

        /* key: allow child to fill */
        #canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* key: full pane */
        h1 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .card {
            background: #101721;
            border: 1px solid #1a2636;
            border-radius: 14px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 8px 0;
        }

        input[type="file"],
        input[type="text"] {
            width: 100%;
            background: #0c1218;
            border: 1px solid #223145;
            color: #e6ebf2;
            border-radius: 10px;
            padding: 8px 10px;
        }

        label {
            font-size: 12px;
            color: #a8b6c7;
        }

        .tiny {
            font-size: 11px;
            color: #94a3b6;
            line-height: 1.35;
        }

        .tag {
            display: inline-block;
            padding: 2px 8px;
            border: 1px solid #223145;
            background: #0b1016;
            border-radius: 999px;
            font-size: 11px;
            color: #a9b6c8
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
            max-height: 150px;
            overflow: auto;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #1a2f46;
            background: #0c1219;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 11px;
            cursor: pointer;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        #err {
            white-space: pre-wrap;
            background: #1a0f12;
            border: 1px solid #3a1d25;
            color: #ffd6de;
            border-radius: 10px;
            padding: 8px;
            display: none;
            max-height: 180px;
            overflow: auto;
        }

        .footer {
            position: absolute;
            right: 10px;
            bottom: 10px;
            background: #0f1318cc;
            padding: 6px 10px;
            border: 1px solid #1b2330;
            border-radius: 10px;
            font-size: 12px
        }

        button {
            background: #182234;
            border: 1px solid #2a3b56;
            color: #e6ebf2;
            border-radius: 10px;
            padding: 8px 10px;
            font-weight: 600;
            cursor: pointer
        }

        button:hover {
            background: #1c2940
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="side">
            <h1>RAWobserved - Graph (clustered forces)</h1>
            <div class="card">
                <div class="row"><input id="file" type="file" accept=".RAWobserved,.txt,.tsv" /></div>
                <div id="status" class="tiny">Choose a <b>.RAWobserved</b> file to begin.</div>
                <div id="err"></div>
            </div>
            <div class="card">
                <label>Find node</label>
                <input id="search" type="text" placeholder="Type node id … (e.g., 1000000) and press Enter" />
                <div class="tiny">Pan: drag • Zoom: wheel/trackpad • Hover: highlight neighbors • Click cluster chip to
                    zoom.</div>
            </div>
            <div class="card">
                <div class="row" style="gap:8px">
                    <label style="min-width:140px">Edge opacity</label>
                    <input id="edgeAlpha" type="range" min="2" max="40" value="12" />
                    <span id="edgeAlphaVal" class="tag">0.12</span>
                </div>
                <div class="row" style="gap:8px">
                    <label style="min-width:140px">Label density</label>
                    <input id="labelPct" type="range" min="0" max="40" value="10" />
                    <span id="labelPctVal" class="tag">10%</span>
                </div>
                <div class="row" style="gap:6px">
                    <label style="flex:1">Show inter-cluster edges</label>
                    <input id="toggleCross" type="checkbox" checked />
                </div>
                <div class="row" style="gap:8px">
                    <label style="min-width:140px">Force iterations</label>
                    <input id="iters" type="range" min="100" max="4000" value="1200" />
                    <span id="itersVal" class="tag">1200</span>
                </div>
                <div class="row" style="gap:8px">
                    <label style="min-width:140px">Intra-edge spring</label>
                    <input id="kSpring" type="range" min="10" max="200" value="80" />
                    <span id="kSpringVal" class="tag">0.80</span>
                </div>
                <div class="row" style="gap:8px">
                    <label style="min-width:140px">Repulsion</label>
                    <input id="kRepel" type="range" min="50" max="800" value="300" />
                    <span id="kRepelVal" class="tag">300</span>
                </div>
                <div class="row"><button id="relayout">Re-layout clusters</button></div>
                <div class="tiny">Force layout runs <i>inside each cluster only</i>. Clusters are spaced around a ring
                    so neighborhoods don’t overlap. All edges are drawn.</div>
            </div>
            <div class="card">
                <label>Clusters</label>
                <div id="legend" class="legend"></div>
            </div>
        </div>

        <div id="stage">
            <canvas id="canvas"></canvas>
            <div class="footer">Nodes: <span id="nodeCount">0</span> • Edges: <span id="edgeCount">0</span> • Clusters:
                <span id="comCount">0</span></div>
        </div>
    </div>

    <script>
        (function () {
            // ---- DOM ----
            const $ = id => document.getElementById(id);
            const fileInput = $('file'), statusEl = $('status'), errEl = $('err');
            const stage = document.getElementById('stage');
            const canvas = $('canvas'), ctx = canvas.getContext('2d');
            const search = $('search'), legend = $('legend');
            const edgeAlpha = $('edgeAlpha'), edgeAlphaVal = $('edgeAlphaVal');
            const labelPct = $('labelPct'), labelPctVal = $('labelPctVal');
            const toggleCross = $('toggleCross');
            const iters = $('iters'), itersVal = $('itersVal');
            const kSpring = $('kSpring'), kSpringVal = $('kSpringVal');
            const kRepel = $('kRepel'), kRepelVal = $('kRepelVal');
            const relayoutBtn = $('relayout');
            const nodeCountEl = $('nodeCount'), edgeCountEl = $('edgeCount'), comCountEl = $('comCount');

            // ---- State ----
            let nodes = [], indexOf = new Map(), clusters = {}, clusterOf = {}, clusterColors = {}, degrees = {}, edges = [], adjacency = new Map();
            let N = 0, pos = [], vel = [], clusterInfo = {}, cam = { x: 0, y: 0, scale: 1 }, hoverIdx = -1;
            let viewW = 0, viewH = 0, dpr = 1;

            // ---- Utils ----
            const TAU = Math.PI * 2;
            const clamp = (v, min, max) => v < min ? min : (v > max ? max : v);
            const rand = (a, b) => a + Math.random() * (b - a);
            const colorFor = k => `hsl(${(137.508 * k) % 360},70%,55%)`;
            const hsla = (h, a) => h.replace('hsl', 'hsla').replace(')', `, ${a})`);
            const setStatus = msg => statusEl.innerHTML = msg;
            const showError = msg => { errEl.style.display = 'block'; errEl.textContent = msg; };
            const clearError = () => { errEl.style.display = 'none'; errEl.textContent = ''; };

            // Label Propagation clustering
            function lpa(arr, adj, maxIter = 25) {
                const label = Object.create(null); arr.forEach(n => label[n] = n);
                let changed = true, it = 0;
                while (changed && it < maxIter) {
                    changed = false; it++;
                    const order = arr.slice(); for (let i = order.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[order[i], order[j]] = [order[j], order[i]]; }
                    for (const n of order) {
                        const nbrs = adj.get(n) || []; if (!nbrs.length) continue;
                        const cnt = Object.create(null);
                        for (const m of nbrs) { const L = label[m]; cnt[L] = (cnt[L] || 0) + 1; }
                        let best = label[n], bc = -1;
                        for (const L in cnt) { const c = cnt[L]; if (c > bc || (c === bc && L < best)) { bc = c; best = L; } }
                        if (best !== label[n]) { label[n] = best; changed = true; }
                    }
                }
                const map = Object.create(null); let idx = 0; const part = Object.create(null);
                for (const n of arr) { const L = label[n]; if (map[L] == null) map[L] = idx++; part[n] = map[L]; }
                return part;
            }

            // ---- Build ----
            fileInput.addEventListener('change', e => {
                clearError();
                const f = e.target.files && e.target.files[0]; if (!f) { setStatus('No file selected.'); return; }
                setStatus('Reading…');
                const r = new FileReader();
                r.onerror = () => showError('Failed to read file.');
                r.onload = () => { try { build(String(r.result || '')); } catch (err) { showError('Error: ' + (err?.stack || err)); } };
                r.readAsText(f);
            });

            function build(text) {
                setStatus('Parsing…');
                const lines = text.split(/\r?\n/);
                const nodeSet = new Set(), edgeSet = new Set();
                adjacency = new Map(); edges = [];
                for (const raw of lines) {
                    if (!raw) continue;
                    const p = raw.split('\t'); if (p.length < 2) continue;
                    const a = (p[0] || '').trim(), b = (p[1] || '').trim(); if (!a || !b) continue;
                    nodeSet.add(a); nodeSet.add(b);
                    const key = (a <= b) ? a + '|' + b : b + '|' + a; if (edgeSet.has(key)) continue;
                    edgeSet.add(key); edges.push([a, b]);
                    if (!adjacency.has(a)) adjacency.set(a, new Set());
                    if (!adjacency.has(b)) adjacency.set(b, new Set());
                    adjacency.get(a).add(b); adjacency.get(b).add(a);
                }
                nodes = Array.from(nodeSet); if (!nodes.length) throw new Error('No nodes parsed. Expected lines like: node1\\tnode2\\tweight');
                degrees = {}; nodes.forEach(n => degrees[n] = (adjacency.get(n) || new Set()).size); N = nodes.length;

                setStatus('Detecting clusters…');
                const part = lpa(nodes, adjacency);
                clusters = {}; clusterColors = {}; clusterOf = {};
                nodes.forEach(n => { const c = part[n]; (clusters[c] || (clusters[c] = [])).push(n); clusterOf[n] = c; if (clusterColors[c] == null) clusterColors[c] = colorFor(c); });

                const clusterOrder = Object.keys(clusters).map(c => ({ c: +c, size: clusters[c].length })).sort((A, B) => B.size - A.size).map(o => o.c);
                clusterOrder.forEach(c => clusters[c].sort((a, b) => degrees[b] - degrees[a] || (a < b ? -1 : 1)));
                nodes = []; clusterOrder.forEach(c => nodes.push(...clusters[c])); indexOf = new Map(nodes.map((id, i) => [id, i]));

                placeClustersOnRing(clusterOrder);
                runPerClusterForces();

                legend.innerHTML = '';
                clusterOrder.forEach(c => {
                    const chip = document.createElement('div'); chip.className = 'chip';
                    const dot = document.createElement('div'); dot.className = 'dot'; dot.style.background = clusterColors[c];
                    const span = document.createElement('span'); span.textContent = `Cluster ${c} • ${clusters[c].length}`;
                    chip.appendChild(dot); chip.appendChild(span);
                    chip.title = 'Zoom to this cluster';
                    chip.onclick = () => zoomToCluster(c);
                    legend.appendChild(chip);
                });

                nodeCountEl.textContent = String(N);
                edgeCountEl.textContent = String(edges.length);
                comCountEl.textContent = String(clusterOrder.length);

                setStatus('Rendered ✓  (pan/zoom/hover/search available)');
                resize(); // ensure full-viewport draw
            }

            function placeClustersOnRing(clusterOrder) {
                const ringR = Math.max(260, Math.min(viewW, viewH) / 2 - 80);
                clusterInfo = {};
                const base = 36; let k = 0;
                for (const cid of clusterOrder) {
                    const theta = TAU * (k / clusterOrder.length);
                    const cx = ringR * Math.cos(theta), cy = ringR * Math.sin(theta);
                    const r = base + 6 * Math.sqrt(clusters[cid].length);
                    clusterInfo[cid] = { cx, cy, r }; k++;
                }
                pos = new Array(N); vel = new Array(N);
                for (const cid of clusterOrder) {
                    const { cx, cy, r } = clusterInfo[cid];
                    for (const n of clusters[cid]) {
                        const i = indexOf.get(n), ang = Math.random() * TAU, rad = Math.sqrt(Math.random()) * r * 0.9;
                        pos[i] = { x: cx + rad * Math.cos(ang), y: cy + rad * Math.sin(ang) }; vel[i] = { x: 0, y: 0 };
                    }
                }
                cam.x = 0; cam.y = 0; cam.scale = 1;
            }

            // ---- Forces (per cluster) ----
            function runPerClusterForces() {
                const ITER = Number(iters.value), kEdge = Number(kSpring.value) / 100, kRep = Number(kRepel.value), dt = 0.02;
                for (let it = 0; it < ITER; it++) {
                    for (let i = 0; i < N; i++) { vel[i].x *= 0.85; vel[i].y *= 0.85; }
                    for (const cid in clusters) {
                        const members = clusters[cid];
                        // repulsion
                        for (let a = 0; a < members.length; a++) {
                            const ia = indexOf.get(members[a]);
                            for (let b = a + 1; b < members.length; b++) {
                                const ib = indexOf.get(members[b]);
                                let dx = pos[ia].x - pos[ib].x, dy = pos[ia].y - pos[ib].y, d2 = dx * dx + dy * dy;
                                if (d2 < 1e-4) { pos[ia].x += Math.random(); pos[ia].y += Math.random(); d2 = 1; }
                                const inv = 1 / Math.sqrt(d2), f = kRep * inv * inv, fx = f * dx * inv, fy = f * dy * inv;
                                vel[ia].x += fx * dt; vel[ia].y += fy * dt; vel[ib].x -= fx * dt; vel[ib].y -= fy * dt;
                            }
                        }
                    }
                    // springs (intra)
                    for (const [a, b] of edges) {
                        if (clusterOf[a] !== clusterOf[b]) continue;
                        const i = indexOf.get(a), j = indexOf.get(b);
                        const dx = pos[j].x - pos[i].x, dy = pos[j].y - pos[i].y;
                        const dist = Math.max(0.001, Math.hypot(dx, dy)), ideal = 20;
                        const f = kEdge * (dist - ideal), fx = f * dx / dist, fy = f * dy / dist;
                        vel[i].x += fx * dt; vel[i].y += fy * dt; vel[j].x -= fx * dt; vel[j].y -= fy * dt;
                    }
                    // integrate & keep within cluster disc
                    for (const cid in clusters) {
                        const { cx, cy, r } = clusterInfo[cid], maxR = r * 0.98;
                        for (const n of clusters[cid]) {
                            const i = indexOf.get(n);
                            pos[i].x += vel[i].x * dt; pos[i].y += vel[i].y * dt;
                            const dx = pos[i].x - cx, dy = pos[i].y - cy, d = Math.hypot(dx, dy);
                            if (d > maxR) { const t = (d - maxR) / d; pos[i].x -= dx * t; pos[i].y -= dy * t; vel[i].x *= 0.5; vel[i].y *= 0.5; }
                        }
                    }
                }
                draw();
            }

            // ---- Rendering & sizing ----
            function resize() {
                // measure the container (CSS pixels)
                const rect = stage.getBoundingClientRect();
                viewW = Math.max(1, Math.floor(rect.width));
                viewH = Math.max(1, Math.floor(rect.height));

                // HiDPI backing store (device pixels)
                dpr = Math.max(1, window.devicePixelRatio || 1);
                canvas.width = viewW * dpr;
                canvas.height = viewH * dpr;

                // draw in CSS pixels; browser scales to device pixels
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                draw();
            }
            window.addEventListener('resize', resize);
            const ro = new ResizeObserver(resize);
            ro.observe(stage);

            function worldToScreen(x, y) {
                const cx = viewW / 2, cy = viewH / 2;
                return { x: Math.round(cx + (x + cam.x) * cam.scale), y: Math.round(cy + (y + cam.y) * cam.scale) };
            }
            function screenToWorld(sx, sy) {
                const cx = viewW / 2, cy = viewH / 2;
                return { x: (sx - cx) / cam.scale - cam.x, y: (sy - cy) / cam.scale - cam.y };
            }
            function clearCanvas() { ctx.clearRect(0, 0, viewW, viewH); }

            function draw() {
                clearCanvas();
                if (!nodes.length) return;
                const showCross = toggleCross.checked, alphaBase = Number(edgeAlpha.value) / 100;

                // edges
                ctx.lineWidth = Math.max(0.5, 0.6 * cam.scale); ctx.globalCompositeOperation = 'source-over';
                for (const [a, b] of edges) {
                    const ia = indexOf.get(a), ib = indexOf.get(b); const ca = clusterOf[a], cb = clusterOf[b];
                    const intra = (ca === cb); if (!intra && !showCross) continue;
                    const p1 = worldToScreen(pos[ia].x, pos[ia].y), p2 = worldToScreen(pos[ib].x, pos[ib].y);
                    ctx.strokeStyle = hsla(clusterColors[ca], intra ? alphaBase : Math.max(0.03, alphaBase * 0.45));
                    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                }

                // nodes
                const rNode = Math.max(2, 3 * cam.scale);
                for (let i = 0; i < nodes.length; i++) {
                    const p = worldToScreen(pos[i].x, pos[i].y);
                    ctx.fillStyle = clusterColors[clusterOf[nodes[i]]];
                    ctx.beginPath(); ctx.arc(p.x, p.y, rNode, 0, TAU); ctx.fill();
                }

                // labels
                const pct = Number(labelPct.value); labelPctVal.textContent = pct + '%';
                const showCount = Math.max(3, Math.round(N * pct / 100));
                const top = nodes.slice().sort((a, b) => degrees[b] - degrees[a] || (a < b ? -1 : 1)).slice(0, showCount);
                if (cam.scale > 0.6 || pct >= 10) {
                    ctx.font = `${Math.max(10, Math.floor(11 * cam.scale))}px system-ui, sans-serif`;
                    ctx.textBaseline = 'middle'; ctx.fillStyle = '#e6edf8';
                    for (const id of top) { const i = indexOf.get(id), p = worldToScreen(pos[i].x, pos[i].y); ctx.fillText(id, p.x + 6, p.y); }
                }

                // hover
                if (hoverIdx >= 0) {
                    const nid = nodes[hoverIdx], neigh = adjacency.get(nid) || new Set();
                    ctx.lineWidth = Math.max(1.2, 1.6 * cam.scale); ctx.strokeStyle = '#ffffffbb';
                    for (const m of neigh) {
                        const ia = hoverIdx, ib = indexOf.get(m);
                        const p1 = worldToScreen(pos[ia].x, pos[ia].y), p2 = worldToScreen(pos[ib].x, pos[ib].y);
                        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                    const p = worldToScreen(pos[hoverIdx].x, pos[hoverIdx].y);
                    ctx.strokeStyle = '#ffffffaa'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, rNode + 2, 0, TAU); ctx.stroke();
                }
            }

            // ---- Interaction ----
            let panning = false, lastX = 0, lastY = 0;
            canvas.addEventListener('mousedown', e => { panning = true; lastX = e.clientX; lastY = e.clientY; });
            window.addEventListener('mouseup', () => panning = false);
            window.addEventListener('mousemove', e => {
                if (!nodes.length) return;
                if (panning) { cam.x += (e.clientX - lastX) / cam.scale; cam.y += (e.clientY - lastY) / cam.scale; lastX = e.clientX; lastY = e.clientY; draw(); return; }
                // hover
                let best = -1, bestD = 18;
                for (let i = 0; i < nodes.length; i++) {
                    const p = worldToScreen(pos[i].x, pos[i].y);
                    const d = Math.hypot(p.x - e.clientX, p.y - e.clientY);
                    if (d < bestD) { bestD = d; best = i; }
                }
                hoverIdx = best; draw();
            });
            canvas.addEventListener('wheel', e => {
                if (!nodes.length) return; e.preventDefault();
                const before = screenToWorld(e.clientX, e.clientY), zoom = Math.exp(-e.deltaY * 0.0012);
                cam.scale = clamp(cam.scale * zoom, 0.2, 6);
                const after = screenToWorld(e.clientX, e.clientY);
                cam.x += before.x - after.x; cam.y += before.y - after.y; draw();
            }, { passive: false });

            // controls
            edgeAlpha.addEventListener('input', () => { edgeAlphaVal.textContent = (Number(edgeAlpha.value) / 100).toFixed(2); draw(); });
            labelPct.addEventListener('input', () => { labelPctVal.textContent = labelPct.value + '%'; draw(); });
            toggleCross.addEventListener('change', draw);
            iters.addEventListener('input', () => itersVal.textContent = iters.value);
            kSpring.addEventListener('input', () => kSpringVal.textContent = (Number(kSpring.value) / 100).toFixed(2));
            kRepel.addEventListener('input', () => kRepelVal.textContent = kRepel.value);
            relayoutBtn.addEventListener('click', () => { setStatus('Re-layouting clusters…'); runPerClusterForces(); setStatus('Rendered ✓'); });

            search.addEventListener('keydown', e => {
                if (e.key !== 'Enter' || !nodes.length) return;
                const q = search.value.trim(); if (!indexOf.has(q)) { setStatus(`Node "${q}" not found.`); return; }
                const i = indexOf.get(q); hoverIdx = i; const p = pos[i]; cam.x = -p.x; cam.y = -p.y; cam.scale = 1.8; draw();
            });

            function zoomToCluster(cid) {
                if (!clusters[cid] || !clusters[cid].length) return;
                const { cx, cy } = clusterInfo[cid]; cam.x = -cx; cam.y = -cy; cam.scale = 1.6; draw();
            }

            // ---- Init ----
            function init() {
                edgeAlphaVal.textContent = (Number(edgeAlpha.value) / 100).toFixed(2);
                labelPctVal.textContent = labelPct.value + '%';
                itersVal.textContent = iters.value;
                kSpringVal.textContent = (Number(kSpring.value) / 100).toFixed(2);
                kRepelVal.textContent = kRepel.value;
                setStatus('Choose a .RAWobserved file to begin.');
                resize(); // stage observer keeps it full-size
            }
            window.addEventListener('load', init);
        })();
    </script>
</body>

</html>